# Взаимодействие веб-приложения с нейросетью

## 1. Входные данные для нейросети (от веб-приложения)

### Структура данных

Данные передаются в строгом формате JSON с обязательной валидацией типов и диапазонов значений. Перед отправкой данные проходят предварительную обработку в приложении.

### Геопространственные данные

- **Координаты**: Широта и долгота с точностью до 6 десятичных знаков
- **Высота над уровнем моря**: В метрах из GPS/Glonass-датчиков
- **Скорость движения**: Км/ч, рассчитанная через дифференциацию координат за последнюю секунду
- **Точность позиционирования**: Радиус ошибки в метрах, извлекаемый из geolocation API

### Физиологические метрики

- **Пульс (BPM)**: Из Bluetooth-устройств (например, сердечного монитора) или оценка через камеру
- **Ускорение по осям X/Y/Z**: М/с² из акселерометра/гироскопа (для анализа стиля бега/ходьбы)

### Временные параметры

- **Длительность текущей тренировки**: В миллисекундах, с момента запуска
- **Таймстампы последних 50 точек маршрута**: Для анализа динамики

### Контекстуальные данные

- **Тип тренировки**: Бег, велосипед, ходьба — выбран пользователем или определен автоматически через ML-классификатор
- **Целевая дистанция/время**: Если задано
- **Данные о погоде**: Температура, влажность, осадки из сторонних API (например, OpenWeatherMap), привязанные к текущим координатам

### Исторические данные пользователя

- **Средняя скорость за последние 10 тренировок**
- **Частота остановок (паузы) за предыдущие сессии**
- **Данные о перегрузке**: Например, частота пульса выше порога более 2 минут

### Метаданные сессии

- **Уникальный ID сессии**: UUID, генерируемый приложением
- **Тип устройства**: iOS/Android, модель, версия ОС
- **Статус разрешений**: GPS, микрофон, доступ к датчикам

### Анонимизация и шифрование

Все данные анонимизируются перед отправкой (удаление персональных данных, таких как имя, email). Для чувствительных метрик (пульс) используется шифрование AES-256.

## 2. Выходные данные от нейросети (в приложение)

### Формат данных

Данные возвращаются в формате JSON с четкой схемой, валидируемой на стороне приложения.

### Рекомендации по маршруту

- **Список точек для корректировки пути**: Широта, долгота, тип изменения ("избегать подъема", "снизить скорость", "перейти на асфальт")
- **Вероятность успешного завершения тренировки**: 0–100%, с комментарием ("Высокий риск травмы из-за уклона 15%")

### Аудио-подсказки

- **Текст для синтеза речи**: Например, "Скорость ниже целевой на 15%, увеличьте шаг", с меткой приоритета (критичный, информационный, рекомендация)
- **Временные метки**: Для синхронизации с аудио-ассистентом (например, "произнести через 10 секунд")

### Аналитика нагрузки

- **Оценка мышечной усталости**: 0–10 баллов на основе данных акселерометра и пульса
- **Рекомендации по отдыху**: Например, "Рекомендуется пауза через 2 минуты"

### Прогнозы

- **Ожидаемое время завершения тренировки**: С доверительным интервалом ±5%
- **Прогноз дистанции**: При текущей скорости (с учетом текущего уклона и погоды)

### Системные метрики

- **Статус обработки запроса**: Success, error, timeout
- **Версия используемой модели**: Для отслеживания обновлений

### Приоритеты передачи

Данные с высоким приоритетом (например, "критическая ошибка GPS") отправляются через WebSocket с приоритетом high, остальные — через REST API.

## 3. Узлы связи между приложением и нейросетью

### 3.1. Архитектура взаимодействия

#### Клиентская часть (веб-приложение)

##### Предобработчик данных

- **Фильтрация шума**: Из GPS-данных (фильтр Калмана)
- **Нормализация числовых метрик**: Например, пульс в диапазоне [60, 200] BPM
- **Сжатие данных**: Протокол Protobuf для снижения объема передачи

##### Очередь отправки

- **Буферизация данных**: При слабом интернете (макс. 5 минут истории)
- **Приоритезация**: Геоданные и пульс > метрики погоды > исторические данные

#### Серверная часть

##### API-шлюз

- **REST-эндпоинты**: 
  - Отправка данных: `/api/v1/training-data`
  - Получение ответов: `/api/v1/recommendations`
- **WebSocket-соединение**: Для потоковой передачи критичных данных (например, ws://api.example.com/training-stream)
- **Аутентификация**: Через JWT-токены с коротким TTL (15 минут), обновляемыми при каждом запросе

##### Микросервисы

###### Data Ingestion Service

- **Прием данных**: Проверяет целостность, сохраняет в временный кэш (Redis)
- **Дублирование данных**: В лог-базу (Elasticsearch) для аудита

###### ML Inference Service

- **Запуск нейросети**: Через TensorFlow Serving или PyTorch Serve
- **Поддержка нескольких моделей**:
  - `route_optimizer`: Анализ маршрута
  - `fatigue_predictor`: Оценка усталости
  - `time_forecaster`: Прогноз времени
- **Автоматический масштабинг**: Контейнеров (Kubernetes) при нагрузке > 100 запросов/сек

###### Audio Synthesis Service

- **Преобразование текста в аудио**: Через TTS-модель (например, Coqui TTS)
- **Возврат данных**: URL для скачивания аудиофайла (или бинарные данные в base64)

##### Сторонние интеграции

- **Погодные API**: OpenWeatherMap через кэширующий прокси (Cloudflare)
- **База данных исторических данных пользователя**: PostgreSQL с шифрованием полей

### 3.2. Безопасность и надежность

#### Шифрование

- **Все данные**: Между клиентом и сервером передаются через TLS 1.3
- **Чувствительные поля**: Пульс, координаты шифруются на клиенте AES-256 перед отправкой

#### Обработка ошибок

- **Таймауты запросов**: 5 секунд для REST, 30 секунд для WebSocket
- **Автоматический retry**: С экспоненциальной задержкой (макс. 3 попытки)
- **Логирование ошибок**: В Sentry с группировкой по типу (network, model, validation)

#### Масштабируемость

- **Кэширование**: Часто запрашиваемых данных (например, прогнозы для популярных маршрутов) через Redis
- **Стратегия fallback**: При недоступности ML-сервиса используется простая логика на основе правил (например, "если уклон > 10%, снизить скорость на 20%")

### 3.3. Специфика для Android-версии (Capacitor)

#### Оптимизация мобильных ресурсов

- **Отправка данных**: Только при активном использовании приложения (через capacitor-background-task для фоновых запросов)
- **Сжатие данных**: До 10% исходного объема перед отправкой (протокол Brotli)

#### Диспетчеризация запросов

- **При слабом сигнале**: (LTE/3G) автоматически снижается частота отправки данных (с 1 секунды до 5 секунд)
- **Критичные данные**: Например, пульс выше 180 BPM отправляются немедленно, игнорируя ограничения частоты

#### Локальный кэш

- **Хранение данных**: Последних 10 минут данных локально (IndexedDB) для восстановления при потере соединения

### 3.4. Мониторинг и обновление

#### Трассировка запросов

- **Использование OpenTelemetry**: Для отслеживания latency между этапами обработки (клиент → API-шлюз → ML-сервис)

#### A/B-тестирование моделей

- **Динамическое переключение**: Между версиями моделей через feature flags (LaunchDarkly)
- **Сбор метрик эффективности**: Например, снижение ошибок прогноза времени на 15% после обновления модели

#### Обновление моделей

- **Автоматический деплой**: Новых версий через CI/CD (GitHub Actions + Kubernetes)
- **Backward compatibility**: Новые версии поддерживают старые схемы входных данных в течение 30 дней

## Заключение

Взаимодействие строится на четком разделении ответственности между клиентом (предобработка, визуализация), сервером (обработка данных, безопасность) и нейросетевыми сервисами (инференс, прогнозы). Все узлы обеспечивают низкую задержку (<200 мс для критичных данных), безопасность данных и отказоустойчивость.